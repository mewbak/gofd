package explicit

import (
	"bitbucket.org/gofd/gofd/core"
	"fmt"
)

type Alldifferent_Offset struct {
	vars             []core.VarId
	offsets          []int
	outCh            chan<- *core.ChangeEvent
	inCh             <-chan *core.ChangeEntry
	varidToOffsetMap map[core.VarId]int
	varidToDomainMap map[core.VarId]*core.ExDomain
	id               core.PropId
	store            *core.Store
}

func (this *Alldifferent_Offset) Start(store *core.Store) {
	loggerDebug := core.GetLogger().DoDebug()
	if loggerDebug {
		core.GetLogger().Dln("Alldifferent_Offset_'initial consistency check'")
	}
	// initial check
	evt := core.CreateChangeEvent()
	this.initialCheck(evt)
	this.outCh <- evt // send changes to store

	var changedDomain *core.ExDomain
	var varidChanged core.VarId
	for changeEntry := range this.inCh {
		if loggerDebug {
			msg := "%s_'Incoming Change for %s'"
			core.GetLogger().Df(msg, this, store.GetName(changeEntry.GetID()))
		}
		evt = core.CreateChangeEvent()
		varidChanged = changeEntry.GetID()
		changedDomain = this.varidToDomainMap[varidChanged]
		changedDomain.Removes(changeEntry.GetValues())
		this.inOutAll(varidChanged, evt)
		if loggerDebug {
			msg := "%s_propagate_'communicate change, evt-value: %s'"
			core.GetLogger().Df(msg, this, evt)
		}
		this.outCh <- evt // send changes to store
	}
}

func (this *Alldifferent_Offset) initialCheck(evt *core.ChangeEvent) {
	for _, varId := range this.vars {
		this.inOutAll(varId, evt)
	}
}

/*
	x x D x
	D x x x
	x x x D
	x D x x

	Reihe (Array-Index) und Spalte
	+0
	+1
	+2
	+3

	D0!=D1+1
	D0!=D2+2
	D0!=D3+3

	D1!=D2+1
	D1!=D3+2

	D2!=D3+1
*/

// inOutAll if inDomain is Fixed remove that value (plus/minus offset from
// all other domains.
// Example: X:{6}, Y:{6,7}, Z:{5,6,7} --> X:{6}, Y:{7}, Z:{5,7}
func (this *Alldifferent_Offset) inOutAll(inVarId core.VarId,
	evt *core.ChangeEvent) {
	inDomain := this.varidToDomainMap[inVarId]
	if inDomain.IsGround() {
		fixed_value := inDomain.GetAnyElement()
		for _, outVarId := range this.vars {
			if inVarId == outVarId {
				continue
			}
			outDomain := this.varidToDomainMap[outVarId]
			// offset-difference. See example above for illustration
			diff := this.varidToOffsetMap[outVarId] -
				this.varidToOffsetMap[inVarId]
			valToRemove := fixed_value + diff
			var chEntry *core.ChangeEntry

			if outDomain.Contains(valToRemove) {
				chEntry = core.CreateChangeEntry(outVarId)
				chEntry.Add(valToRemove)
			}
			diff = this.varidToOffsetMap[inVarId] -
				this.varidToOffsetMap[outVarId]
			valToRemove = fixed_value + diff

			if outDomain.Contains(valToRemove) {
				if chEntry == nil {
					chEntry = core.CreateChangeEntry(outVarId)
				}
				chEntry.Add(valToRemove)
			}

			if chEntry != nil {
				evt.AddChangeEntry(chEntry)
			}
		}
	}
}

// CreateAlldifferentOffset creates one propagator that ensure that each
// variable subject to an individual offset if not equal to any other
// variable and its offset.
func CreateAlldifferent_Offset(vars []core.VarId,
	offsets []int) *Alldifferent_Offset {
	if len(vars)-1 != len(offsets) {
		panic("AlldifferentOffset-Creation: len(vars)-1 != len(offsets)")
	}
	if core.GetLogger().DoDebug() {
		core.GetLogger().Dln("CreateAlldifferent_Offset-propagator")
	}
	//for better calculating in propagation-function
	offsets_new := make([]int, len(offsets)+1)
	offsets_new[0] = 0 //offset to itself, not used
	for i, off := range offsets {
		offsets_new[i+1] = off
	}
	prop := new(Alldifferent_Offset)
	prop.vars = vars
	prop.offsets = offsets_new
	prop.varidToOffsetMap = make(map[core.VarId]int, len(prop.vars))
	for i, varid := range vars {
		prop.varidToOffsetMap[varid] = offsets_new[i]
	}
	return prop
}

func (this *Alldifferent_Offset) Clone() core.Constraint {
	prop := new(Alldifferent_Offset)
	prop.vars = make([]core.VarId, len(this.vars))
	for i, varid := range this.vars {
		prop.vars[i] = varid
	}
	prop.offsets = make([]int, len(this.offsets))
	for i, off := range this.offsets {
		prop.offsets[i] = off
	}
	prop.varidToOffsetMap = make(map[core.VarId]int, len(this.vars))
	for i, varid := range this.vars {
		prop.varidToOffsetMap[varid] = this.offsets[i]
	}
	return prop
}

// nothing to change below

// Register registers the propagator at the store.
func (this *Alldifferent_Offset) Register(store *core.Store) {
	var domains map[core.VarId]core.Domain
	this.inCh, domains, this.outCh =
		store.RegisterPropagatorMap(this.vars, this.id)
	this.varidToDomainMap = core.GetVaridToExplicitDomainsMap(domains)
	this.store = store
}

// SetID is used by the store to set the propagator's ID, don't use it
// yourself or bad things will happen.
func (this *Alldifferent_Offset) SetID(propID core.PropId) {
	this.id = propID
}

func (this *Alldifferent_Offset) GetID() core.PropId {
	return this.id
}

func (this *Alldifferent_Offset) String() string {
	return fmt.Sprintf("PROP_Alldifferent_Offset-ID: %d ", this.id)
}

func (this *Alldifferent_Offset) GetVarIds() []core.VarId {
	return this.vars
}

func (this *Alldifferent_Offset) GetDomains() []core.Domain {
	return core.ValuesOfMapVarIdToExDomain(this.vars, this.varidToDomainMap)
}

func (this *Alldifferent_Offset) GetInCh() <-chan *core.ChangeEntry {
	return this.inCh
}

func (this *Alldifferent_Offset) GetOutCh() chan<- *core.ChangeEvent {
	return this.outCh
}
